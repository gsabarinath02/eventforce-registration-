<?php

namespace Tests\Feature\Security;

use HiEvents\DomainObjects\EventDomainObject;
use HiEvents\DomainObjects\OrderDomainObject;
use HiEvents\Enums\PaymentProvider;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Support\Facades\Config;
use Tests\TestCase;

/**
 * Security vulnerability tests for Razorpay integration
 * 
 * Tests for common security vulnerabilities:
 * - CSRF protection
 * - Rate limiting
 * - Input validation
 * - Authorization bypass
 * - Information disclosure
 */
class RazorpayVulnerabilityTest extends TestCase
{
    use RefreshDatabase;

    private EventDomainObject $event;
    private OrderDomainObject $order;

    protected function setUp(): void
    {
        parent::setUp();

        Config::set('services.razorpay.key_id', 'rzp_test_vuln_123');
        Config::set('services.razorpay.key_secret', 'test_vuln_secret');
        Config::set('services.razorpay.webhook_secret', 'test_vuln_webhook_secret');

        $this->event = $this->createEvent([
            'settings' => [
                'payment_providers' => [PaymentProvider::RAZORPAY->value],
                'razorpay_key_id' => 'rzp_test_vuln_123',
                'razorpay_key_secret' => 'test_vuln_secret',
                'razorpay_webhook_secret' => 'test_vuln_webhook_secret',
            ]
        ]);

        $this->order = $this->createOrder($this->event);
    }

    /**
     * Test CSRF Protection
     */
    public function test_webhook_endpoint_is_exempt_from_csrf_protection(): void
    {
        // Webhook endpoints should be exempt from CSRF as they come from external services
        $webhookPayload = [
            'event' => 'payment.captured',
            'payload' => [
                'payment' => [
                    'entity' => [
                        'id' => 'pay_test123',
                        'order_id' => 'order_test123',
                        'status' => 'captured',
                    ]
                ]
            ],
        ];

        $webhookBody = json_encode($webhookPayload);
        $signature = hash_hmac('sha256', $webhookBody, 'test_vuln_webhook_secret');

        // Should work without CSRF token
        $response = $this->postJson(
            route('api.public.webhooks.razorpay'),
            $webhookPayload,
            ['X-Razorpay-Signature' => $signature]
        );

        $this->assertNotEquals(419, $response->getStatusCode()); // 419 is CSRF token mismatch
    }

    public function test_payment_endpoints_require_proper_authentication(): void
    {
        // Test order creation without proper session
        $response = $this->postJson(
            route('api.public.events.orders.razorpay.create', [
                'eventId' => $this->event->getId(),
                'orderShortId' => 'invalid_order_id',
            ])
        );

        $this->assertIn($response->getStatusCode(), [404, 422, 401]);
    }

    /**
     * Test Rate Limiting Protection
     */
    public function test_webhook_endpoint_has_reasonable_rate_limiting(): void
    {
        $webhookPayload = [
            'event' => 'payment.captured',
            'payload' => [
                'payment' => [
                    'entity' => [
                        'id' => 'pay_test123',
                        'order_id' => 'order_test123',
                        'status' => 'captured',
                    ]
                ]
            ],
        ];

        $webhookBody = json_encode($webhookPayload);
        $signature = hash_hmac('sha256', $webhookBody, 'test_vuln_webhook_secret');

        $successfulRequests = 0;
        $rateLimitedRequests = 0;

        // Make multiple requests to test rate limiting
        for ($i = 0; $i < 20; $i++) {
            $response = $this->postJson(
                route('api.public.webhooks.razorpay'),
                $webhookPayload,
                ['X-Razorpay-Signature' => $signature]
            );

            if ($response->getStatusCode() === 429) {
                $rateLimitedRequests++;
            } elseif ($response->getStatusCode() === 200) {
                $successfulRequests++;
            }
        }

        // Should allow some requests but eventually rate limit
        $this->assertGreaterThan(0, $successfulRequests);
        // Note: Rate limiting might not be implemented yet, so this is informational
    }

    /**
     * Test Input Validation
     */
    public function test_payment_verification_validates_input_format(): void
    {
        $testCases = [
            // Empty values
            ['razorpay_payment_id' => '', 'razorpay_order_id' => 'order_123', 'razorpay_signature' => 'sig_123'],
            ['razorpay_payment_id' => 'pay_123', 'razorpay_order_id' => '', 'razorpay_signature' => 'sig_123'],
            ['razorpay_payment_id' => 'pay_123', 'razorpay_order_id' => 'order_123', 'razorpay_signature' => ''],
            
            // Invalid formats
            ['razorpay_payment_id' => 'invalid_format', 'razorpay_order_id' => 'order_123', 'razorpay_signature' => 'sig_123'],
            ['razorpay_payment_id' => 'pay_123', 'razorpay_order_id' => 'invalid_format', 'razorpay_signature' => 'sig_123'],
            
            // Extremely long values
            ['razorpay_payment_id' => str_repeat('a', 1000), 'razorpay_order_id' => 'order_123', 'razorpay_signature' => 'sig_123'],
            
            // Special characters
            ['razorpay_payment_id' => 'pay_123<script>', 'razorpay_order_id' => 'order_123', 'razorpay_signature' => 'sig_123'],
        ];

        foreach ($testCases as $testCase) {
            $response = $this->postJson(
                route('api.public.events.orders.razorpay.verify', [
                    'eventId' => $this->event->getId(),
                    'orderShortId' => $this->order->getShortId(),
                ]),
                $testCase
            );

            // Should return validation error, not 500 error
            $this->assertIn($response->getStatusCode(), [400, 422], 
                'Failed for test case: ' . json_encode($testCase));
        }
    }

    public function test_webhook_validates_payload_structure(): void
    {
        $invalidPayloads = [
            // Missing required fields
            ['event' => 'payment.captured'],
            ['payload' => ['payment' => ['entity' => ['id' => 'pay_123']]]],
            
            // Invalid JSON structure
            ['event' => 'payment.captured', 'payload' => 'invalid_structure'],
            
            // Malformed event type
            ['event' => '<script>alert("xss")</script>', 'payload' => ['payment' => ['entity' => ['id' => 'pay_123']]]],
        ];

        foreach ($invalidPayloads as $payload) {
            $webhookBody = json_encode($payload);
            $signature = hash_hmac('sha256', $webhookBody, 'test_vuln_webhook_secret');

            $response = $this->postJson(
                route('api.public.webhooks.razorpay'),
                $payload,
                ['X-Razorpay-Signature' => $signature]
            );

            // Should handle gracefully
            $this->assertIn($response->getStatusCode(), [200, 400, 422]);
        }
    }

    /**
     * Test Authorization Bypass
     */
    public function test_cannot_verify_payment_for_different_event(): void
    {
        $otherEvent = $this->createEvent([
            'settings' => [
                'payment_providers' => [PaymentProvider::RAZORPAY->value],
                'razorpay_key_id' => 'rzp_test_other_123',
                'razorpay_key_secret' => 'test_other_secret',
                'razorpay_webhook_secret' => 'test_other_webhook_secret',
            ]
        ]);

        $paymentId = 'pay_test123';
        $orderId = 'order_test123';
        $signature = hash_hmac('sha256', $orderId . '|' . $paymentId, 'test_vuln_secret');

        // Try to verify payment for different event
        $response = $this->postJson(
            route('api.public.events.orders.razorpay.verify', [
                'eventId' => $otherEvent->getId(),
                'orderShortId' => $this->order->getShortId(),
            ]),
            [
                'razorpay_payment_id' => $paymentId,
                'razorpay_order_id' => $orderId,
                'razorpay_signature' => $signature,
            ]
        );

        // Should not allow cross-event verification
        $this->assertIn($response->getStatusCode(), [404, 403, 422]);
    }

    public function test_cannot_access_other_users_orders(): void
    {
        $otherEvent = $this->createEvent();
        $otherOrder = $this->createOrder($otherEvent);

        $paymentId = 'pay_test123';
        $orderId = 'order_test123';
        $signature = hash_hmac('sha256', $orderId . '|' . $paymentId, 'test_vuln_secret');

        // Try to verify payment for other user's order
        $response = $this->postJson(
            route('api.public.events.orders.razorpay.verify', [
                'eventId' => $this->event->getId(),
                'orderShortId' => $otherOrder->getShortId(),
            ]),
            [
                'razorpay_payment_id' => $paymentId,
                'razorpay_order_id' => $orderId,
                'razorpay_signature' => $signature,
            ]
        );

        // Should not allow access to other user's orders
        $this->assertIn($response->getStatusCode(), [404, 403]);
    }

    /**
     * Test Information Disclosure
     */
    public function test_error_messages_do_not_expose_sensitive_information(): void
    {
        // Test with invalid credentials
        Config::set('services.razorpay.key_secret', 'wrong_secret');

        $paymentId = 'pay_test123';
        $orderId = 'order_test123';
        $signature = 'invalid_signature';

        $response = $this->postJson(
            route('api.public.events.orders.razorpay.verify', [
                'eventId' => $this->event->getId(),
                'orderShortId' => $this->order->getShortId(),
            ]),
            [
                'razorpay_payment_id' => $paymentId,
                'razorpay_order_id' => $orderId,
                'razorpay_signature' => $signature,
            ]
        );

        $responseContent = $response->getContent();

        // Should not expose sensitive configuration
        $this->assertStringNotContainsString('wrong_secret', $responseContent);
        $this->assertStringNotContainsString('test_vuln_secret', $responseContent);
        $this->assertStringNotContainsString('rzp_test_vuln_123', $responseContent);
        $this->assertStringNotContainsString('test_vuln_webhook_secret', $responseContent);
    }

    public function test_webhook_errors_do_not_expose_internal_details(): void
    {
        // Send webhook with invalid signature
        $webhookPayload = [
            'event' => 'payment.captured',
            'payload' => [
                'payment' => [
                    'entity' => [
                        'id' => 'pay_test123',
                        'order_id' => 'order_test123',
                        'status' => 'captured',
                    ]
                ]
            ],
        ];

        $response = $this->postJson(
            route('api.public.webhooks.razorpay'),
            $webhookPayload,
            ['X-Razorpay-Signature' => 'invalid_signature']
        );

        $responseContent = $response->getContent();

        // Should not expose internal configuration or file paths
        $this->assertStringNotContainsString('/app/', $responseContent);
        $this->assertStringNotContainsString('test_vuln_webhook_secret', $responseContent);
        $this->assertStringNotContainsString('HiEvents\\', $responseContent);
    }

    /**
     * Test Injection Attacks
     */
    public function test_prevents_header_injection_in_webhook_signature(): void
    {
        $webhookPayload = ['event' => 'payment.captured'];
        
        // Try header injection in signature
        $maliciousSignature = "valid_signature\r\nX-Injected-Header: malicious_value";

        $response = $this->postJson(
            route('api.public.webhooks.razorpay'),
            $webhookPayload,
            ['X-Razorpay-Signature' => $maliciousSignature]
        );

        // Should handle gracefully without header injection
        $this->assertIn($response->getStatusCode(), [400, 422]);
        
        // Verify no injected headers in response
        $this->assertFalse($response->headers->has('X-Injected-Header'));
    }

    public function test_prevents_ldap_injection_in_payment_data(): void
    {
        // LDAP injection patterns
        $ldapPayloads = [
            'pay_test*)(uid=*))(|(uid=*',
            'pay_test*)(|(password=*))',
            'pay_test*))%00',
        ];

        foreach ($ldapPayloads as $payload) {
            $response = $this->postJson(
                route('api.public.events.orders.razorpay.verify', [
                    'eventId' => $this->event->getId(),
                    'orderShortId' => $this->order->getShortId(),
                ]),
                [
                    'razorpay_payment_id' => $payload,
                    'razorpay_order_id' => 'order_test123',
                    'razorpay_signature' => 'signature_test123',
                ]
            );

            // Should handle gracefully
            $this->assertIn($response->getStatusCode(), [400, 422, 500]);
        }
    }

    /**
     * Test Business Logic Vulnerabilities
     */
    public function test_prevents_race_condition_in_payment_verification(): void
    {
        $paymentId = 'pay_test123';
        $orderId = 'order_test123';
        $signature = hash_hmac('sha256', $orderId . '|' . $paymentId, 'test_vuln_secret');

        // Simulate concurrent requests
        $responses = [];
        for ($i = 0; $i < 5; $i++) {
            $responses[] = $this->postJson(
                route('api.public.events.orders.razorpay.verify', [
                    'eventId' => $this->event->getId(),
                    'orderShortId' => $this->order->getShortId(),
                ]),
                [
                    'razorpay_payment_id' => $paymentId,
                    'razorpay_order_id' => $orderId,
                    'razorpay_signature' => $signature,
                ]
            );
        }

        // All should return consistent results
        $statusCodes = array_map(fn($response) => $response->getStatusCode(), $responses);
        $uniqueStatusCodes = array_unique($statusCodes);
        
        // Should not have inconsistent results due to race conditions
        $this->assertLessThanOrEqual(2, count($uniqueStatusCodes), 
            'Inconsistent status codes suggest race condition: ' . implode(', ', $uniqueStatusCodes));
    }

    public function test_prevents_amount_overflow_attacks(): void
    {
        // Test with extremely large amounts
        $largeAmounts = [
            PHP_INT_MAX,
            '999999999999999999999',
            '1e308', // Float overflow
        ];

        foreach ($largeAmounts as $amount) {
            $response = $this->postJson(
                route('api.public.events.orders.razorpay.create', [
                    'eventId' => $this->event->getId(),
                    'orderShortId' => $this->order->getShortId(),
                ]),
                ['amount' => $amount]
            );

            // Should handle gracefully without overflow
            $this->assertIn($response->getStatusCode(), [400, 422, 500]);
        }
    }
}